本题的难点在于时间复杂度的要求，如果使用暴力的双重循环，时间复杂度为O(n^2)，当数组比较长时，必然超时
所以，要寻求方法降低循环。

减少循环的核心在于：尽可能减少没必要的遍历，并且确保所需的答案一定会被遍历到。<br/>
正确的思路是：从数组h的两侧往中间遍历，记录一个最大面积值，遍历的顺序是：当左值 < 右值时，左下标++，否则右下标--；<br/>
算法非常简单，难的是要理解这个算法，在数学的角度去证明这个算法的正确性。<br/>

首先提供第一条性质：假设得到最大面积时，数组下标分别为i、j，则在坐标j的右侧，所有的下标k（k > j && k < height.length），满足h[k] < h[j].
同理在坐标i的左侧，所有的下标k（k < i && k > 0），满足h[k] < h[i].

证明：<br/>
使用反证法证明：<br/>
假设在坐标j的右侧，存在一个下标k（k > j && k < h.length），使得h[k] >= h[j]；<br/>
ij组成的面积S = min(hi, hj) * (j - i),<br/>
ik组成的面积S1 = min(hi, hk) * (k - i),<br/>
因为hk > hj，所以min(hi, hj) <= min(hi, hk),<br/>
因为h > j,所以h - i > j - i,<br/>
所以S1 > S，与S是最大面积矛盾，所以假设不成立，得证。

这条性质并不能充分的证明算法就一定会遍历到最大面积，不过有助于对算法的理解。

然后是为什么遍历顺序是：当左值 < 右值时，左下标++，否则右下标--；<br/>
主要的困惑在于如何移动双指针才能保证最大的盛水量被遍历到<br/>
假设有左指针left和右指针right，且left指向的值小于right的值，假如我们将右指针左移，则右指针左移后的值和左指针指向的值相比有三种情况<br/>
1、右指针指向的值大于左指针<br/>
这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小<br/>
2、右指针指向的值等于左指针<br/>
这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小<br/>
3、右指针指向的值小于左指针<br/>
这种情况下，容器的高取决于右指针，但是右指针小于左指针，且底也变短了，所以容量盛水量一定变小了<br/>
综上所述，容器高度较大的一侧的移动只会造成容器盛水量减小<br/>
所以应当移动高度较小一侧的指针，并继续遍历，直至两指针相遇<br/>

这个证明也只是为了助于理解。下面给出严谨的算法证明：<br/>
假设：该算法并没有遍历到容量最大的情况<br/>
我们令容量最大时的指针为p_left和p_right。根据题设，我们可以假设遍历时左指针先到达p_left，但是当左指针为p_left时，右指针还没有经过p_right左指针就移动了<br/>
已知当左指针停留在p_left时，它只有在两种场景下会发生改变<br/>
1、左指针和右指针在p_left相遇，则右指针一定在前往p_left的途中经过p_right，与题设矛盾<br/>
2、右指针位于p_right右侧且当前的值大于左指针。则在这种情况下，此时容器的盛水量比题设中最大的盛水量还要大，与题设矛盾<br/>
因此该算法的遍历一定经过了最大的盛水量的情况
